# Medeva Backend Assessment

Backend REST API untuk sistem manajemen karyawan dengan fitur autentikasi, filtering dinamis, dan Swagger documentation.

## ğŸ“‹ Tech Stack

- **Language**: TypeScript
- **Framework**: Express.js
- **ORM**: Prisma
- **Database**: PostgreSQL
- **Authentication**: JWT (Bearer Token)
- **Logging**: Winston + Morgan
- **Documentation**: Swagger/OpenAPI
- **Containerization**: Docker + Docker Compose
- **Package Manager**: pnpm

## ğŸš€ Quick Start

### Prerequisites

- Node.js >= 18.0
- PostgreSQL >= 14
- pnpm >= 8.0
- Docker & Docker Compose (opsional)

### Development Setup

```bash
# 1. Clone repository
git clone <repo-url>
cd backend

# 2. Install dependencies
pnpm install

# 3. Setup environment variables
cp example.env .env

# Edit .env dengan konfigurasi lokal
# DATABASE_URL=postgresql://user:password@localhost:5432/medeva_db

# 4. Setup database
pnpm prisma migrate dev

# 5. Seed data (optional)
pnpm seed

# 6. Start development server
pnpm dev
```

Server akan berjalan di `http://localhost:3150`

### Docker Setup

```bash
# 1. Build dan start services
docker-compose up -d

# 2. Run migrations
docker-compose exec backend pnpm prisma migrate deploy

# 3. Seed data (optional)
docker-compose exec backend pnpm seed

# Check logs
docker-compose logs -f backend

# Stop services
docker-compose down
```

## ğŸ”§ Environment Variables

```env
# Server
NODE_ENV=development
PORT=3150
SERVICE=rest

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/medeva_db

# JWT
JWT_SECRET=your-super-secret-key-change-in-production
JWT_EXPIRY=1h

# Logging
LOG_LEVEL=info
```

## ğŸ“š API Endpoints

### Authentication

```
POST /api/v1/auth/register
  body: { email, username, password }
  response: { user, token }

POST /api/v1/auth/login
  body: { email/username, password }
  response: { user, token }
```

### Employees

```
GET    /api/v1/employees              # List all employees (with filtering)
GET    /api/v1/employees/{id}         # Get employee by ID
POST   /api/v1/employees              # Create employee (ADMIN only)
PUT    /api/v1/employees/{id}         # Update employee (ADMIN only)
DELETE /api/v1/employees/{id}         # Delete employee (ADMIN only)
```

#### Filtering & Pagination

```bash
# Partial search - contains
curl 'http://localhost:3150/api/v1/employees?search=rangga'

# Pagination with limit 10 per page
curl 'http://localhost:3150/api/v1/employees?page=1&limit=10'

# Get all employees (unlimited)
curl 'http://localhost:3150/api/v1/employees?limit=-1'

# Sorting
curl 'http://localhost:3150/api/v1/employees?sortBy=fullName&sortOrder=asc'

# Filter by position
curl 'http://localhost:3150/api/v1/employees?positionId=<uuid>'

# Filter by status
curl 'http://localhost:3150/api/v1/employees?status=active'
```

**Query Parameters:**

- `search`: Filter search (contains, case-insensitive)
- `page`: Halaman (default: 1)
- `limit`: Items per halaman (default: 10, use `-1` for unlimited)
- `sortBy`: Field untuk sorting (fullName, nik, createdAt, updatedAt)
- `sortOrder`: asc/desc (default: asc)
- `positionId`: Filter by position UUID
- `status`: Filter by status (active/inactive)

**Field Aliases** (case-insensitive):

- `fullname` â†’ `fullName`
- `dateofbirth` â†’ `dateOfBirth`
- `placeofbirth` â†’ `placeOfBirth`

### Departments

```
GET    /api/v1/departments                      # List all departments
GET    /api/v1/departments/{id}/positions       # Get position department ID
```

#### Filtering & Pagination

```bash
# List departments with pagination
curl 'http://localhost:3150/api/v1/departments?page=1&limit=10'

# Get all departments (unlimited)
curl 'http://localhost:3150/api/v1/departments?limit=-1'

# Search department
curl 'http://localhost:3150/api/v1/departments?search=IT'
```

**Query Parameters:**

- `search`: Search department name (case-insensitive)
- `page`: Halaman (default: 1)
- `limit`: Items per halaman (default: 10, use `-1` for unlimited)

### Swagger Documentation

Akses dokumentasi interaktif di: `http://localhost:3150/api-docs`

## ğŸ—ï¸ Arsitektur

```
src/
â”œâ”€â”€ controllers/       # Request handlers
â”œâ”€â”€ services/          # Business logic
â”œâ”€â”€ repositories/      # Data access layer
â”œâ”€â”€ entities/          # Data models & interfaces
â”œâ”€â”€ middlewares/       # Express middlewares
â”œâ”€â”€ validations/       # Zod schemas
â”œâ”€â”€ routes/            # API routes definition
â”œâ”€â”€ types/             # TypeScript definitions
â”œâ”€â”€ utils/             # Helper functions
â”œâ”€â”€ pkg/               # Third-party integrations
â”‚   â”œâ”€â”€ logger/        # Winston logger
â”‚   â”œâ”€â”€ prisma/        # Prisma client
â”‚   â””â”€â”€ swagger/       # OpenAPI generator
â””â”€â”€ index.ts           # Application entry point
```

### Layer Responsibilities

- **Controllers** â†’ Parse request, call service, return response
- **Services** â†’ Business logic, validation, error handling
- **Repositories** â†’ Database queries, data transformation
- **Entities** â†’ Type definitions (Error, Query, User, etc.)
- **Middlewares** â†’ Auth, validation, error handling, logging

## âœ¨ Key Features

### 1. Role-Based Access Control

- ADMIN: Full CRUD access
- USER: Read-only access
- Middleware-based role validation

### 2. Comprehensive Error Handling

- Custom error classes (AppError, BadRequestError)
- Prisma error mapping (P2002, P2025, etc.)
- Zod validation error translation
- Centralized error response formatting

### 3. Database Cascading

Relasi antar entity dengan cascade delete:

```
User â†’ Employee: CASCADE (hapus user, employee ikut dihapus)
Department â†’ Position â†’ Employee: CASCADE
```

### 4. Swagger/OpenAPI Integration

- Auto-generated documentation dari Zod schemas
- Interactive API testing di browser
- Real-time spec updates

## ğŸ” Authentication Flow

```
1. POST /auth/login â†’ Get JWT token
2. Set header: Authorization: Bearer <token>
3. Middleware validasi token, extract user info
4. Request proceed dengan user context
```

**Token Payload:**

```json
{
  "id": "user-uuid",
  "role": "ADMIN|USER",
  "iat": 1234567890,
  "exp": 1234571490
}
```

## ğŸ“Š Database Schema

### Users

- id (UUID, Primary Key)
- email (String, Unique)
- username (String, Unique)
- password (String, Hashed with bcrypt)
- role (Enum: USER, ADMIN)
- createdAt, updatedAt

### Employees

- id (UUID, Primary Key)
- userId (UUID, FK to Users, Unique, CASCADE Delete)
- nik (String, Unique, 16 chars)
- fullName (String)
- dateOfBirth (Date)
- placeOfBirth (String)
- address (Text)
- phone (String)
- positionId (UUID, FK to Positions, CASCADE Delete)
- isActive (Boolean, default: true)
- createdAt, updatedAt

### Positions

- id (UUID, Primary Key)
- name (String)
- departmentId (UUID, FK to Departments, CASCADE Delete)
- createdAt, updatedAt

### Departments

- id (UUID, Primary Key)
- name (String, Unique)
- createdAt, updatedAt

## âš ï¸ Trade-offs & Design Decisions

### 1. **Query Key Tidak Fully Dynamic** ğŸ”’

**Issue**: Field filtering saat ini hanya support Employee model fields yang sudah di-hardcode di alias mapping. Client **tidak bisa query relational fields** seperti `user.email` atau `position.name` secara dinamis.

**Current Limitation**:

- âœ… Support: `fullName`, `nik`, `isActive`, `dateOfBirth` (direct fields)
- âŒ Not Support: `user.email`, `position.name`, `department.name` (relational)

**Why**: Prisma relational filtering lebih kompleks dan perlu join/include logic. Hardcoding lebih safe daripada allow arbitrary nested queries.

**Trade-off**:

- âœ… **Benefit**: More secure, prevent N+1 queries, easier to optimize
- âŒ **Cost**: Less flexible, client harus request feature baru untuk each relational field

**Future Improvement**:

- Whitelist specific relational fields (e.g. `allowedRelations: ['user', 'position']`)
- Support dot notation dengan auto include: `{ searchFilters: { 'position.name': 'Manager' } }`
- Query complexity limit untuk prevent abuse

### 2. **No Request Logging Body in Production** ğŸ”’

**Decision**: Log body hanya di development untuk security.

**Benefit**: Hide sensitive data (password, token)
**Cost**: Lebih susah debug production issues

### 3. **JWT Expiry 1 Hour** â°

**Decision**: Token expire dalam 1 jam untuk security.

**Benefit**: Reduce token hijacking window
**Cost**: User harus re-login lebih sering

### 4. **No Redis Caching - Database Indexing Strategy** âš¡

**Decision**: Tidak implement Redis caching layer. Fokus pada database optimization dengan strategic indexing.

**Why**:

- Redis adds operational complexity (infra, monitoring, cache invalidation)
- Database indexing lebih cost-effective untuk dataset size kecil-medium
- Filtering engine sudah optimize dengan Prisma

**Trade-off**:

- âœ… **Benefit**: Simple architecture, fast enough untuk typical queries, no cache invalidation headaches
- âŒ **Cost**: Database disk usage (indexes), slower for extremely large datasets (>1M rows)

**When to Add Redis**:

- Query response time > 500ms for common filters
- Same queries executed 100+ times per hour
- High concurrent load (>100 RPS)

**Implementation Path** (Future):

1. Add `ioredis` to package.json
2. Create `pkg/redis/` module with singleton pattern
3. Implement cache layer in repository methods
4. Add cache invalidation on CREATE/UPDATE/DELETE

## ğŸ§ª Testing

```bash
# Run tests
pnpm test

# Watch mode
pnpm test:watch

# Coverage
pnpm test:coverage
```

## ğŸ“¦ Build & Deploy

```bash
# Build TypeScript
pnpm build

# Start production server
pnpm start

# Or dengan Docker
docker-compose up -d
```

## ğŸ” Debugging

### Enable debug logging

```env
LOG_LEVEL=debug
```

### View Prisma queries

```env
DEBUG=prisma:*
```

### Inspect database

```bash
pnpm prisma studio
```

## ğŸ“ Scripts

```bash
pnpm dev              # Start dev server dengan hot-reload
pnpm build            # Compile TypeScript
pnpm start            # Run production build
pnpm test             # Run unit tests
pnpm seed             # Seed database
pnpm prisma migrate   # Run migrations
pnpm prisma studio    # Open Prisma Studio UI
pnpm format           # Format code
pnpm typecheck        # Check TypeScript types
```

## ğŸš¨ Known Issues & Limitations

1. **No Request Rate Limiting** - Gunakan reverse proxy (nginx) atau library (express-rate-limit)
2. **No CORS Whitelist** - Set CORS_ORIGIN di production
3. **Single Database Connection** - Perlu connection pooling untuk high traffic

## ğŸ‘¤ Author

Rangga Kristna

---

**Last Updated**: November 19, 2025
